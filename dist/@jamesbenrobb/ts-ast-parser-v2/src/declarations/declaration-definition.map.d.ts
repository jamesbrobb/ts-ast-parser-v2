import * as ts from "typescript";
import { DefaultSyntaxKindToTSNodeDeclarationMap } from "../syntax-kind";
import { DeclarationDefinitionMap } from "./declaration-definition.types";
import { CallExpression, ConstructorDeclaration, Decorator, EnumMember, ExpressionWithTypeArguments, FunctionDeclaration, GetAccessorDeclaration, HeritageClause, ImportClause, ImportDeclaration, ImportSpecifier, InterfaceDeclaration, MethodDeclaration, NamedImports, NamespaceImport, ParameterDeclaration, PropertyDeclaration, PropertySignature, SetAccessorDeclaration, TupleTypeNode, NamedTupleMember, TypeLiteral, TypeParameterDeclaration, TypeReferenceNode, VariableDeclaration, ClassDeclaration, EnumDeclaration, TypeAliasDeclaration } from "./definitions";
import { DeclarationKind } from "./declaration-kind.types";
export type DefaultDeclarationKindMap = {
    [ts.SyntaxKind.ImportDeclaration]: ImportDeclaration;
    [ts.SyntaxKind.ImportClause]: ImportClause;
    [ts.SyntaxKind.NamespaceImport]: NamespaceImport;
    [ts.SyntaxKind.NamedImports]: NamedImports;
    [ts.SyntaxKind.ImportSpecifier]: ImportSpecifier;
    [ts.SyntaxKind.ClassDeclaration]: ClassDeclaration;
    [ts.SyntaxKind.InterfaceDeclaration]: InterfaceDeclaration;
    [ts.SyntaxKind.Decorator]: Decorator;
    [ts.SyntaxKind.TypeParameter]: TypeParameterDeclaration;
    [ts.SyntaxKind.TypeReference]: TypeReferenceNode;
    [ts.SyntaxKind.ExpressionWithTypeArguments]: ExpressionWithTypeArguments;
    [ts.SyntaxKind.TypeAliasDeclaration]: TypeAliasDeclaration;
    [ts.SyntaxKind.TypeLiteral]: TypeLiteral;
    [ts.SyntaxKind.HeritageClause]: HeritageClause;
    [ts.SyntaxKind.Constructor]: ConstructorDeclaration;
    [ts.SyntaxKind.PropertyDeclaration]: PropertyDeclaration;
    [ts.SyntaxKind.PropertySignature]: PropertySignature;
    [ts.SyntaxKind.MethodDeclaration]: MethodDeclaration;
    [ts.SyntaxKind.GetAccessor]: GetAccessorDeclaration;
    [ts.SyntaxKind.SetAccessor]: SetAccessorDeclaration;
    [ts.SyntaxKind.TupleType]: TupleTypeNode;
    [ts.SyntaxKind.NamedTupleMember]: NamedTupleMember;
    [ts.SyntaxKind.EnumDeclaration]: EnumDeclaration;
    [ts.SyntaxKind.EnumMember]: EnumMember;
    [ts.SyntaxKind.VariableDeclaration]: VariableDeclaration;
    [ts.SyntaxKind.Parameter]: ParameterDeclaration;
    [ts.SyntaxKind.CallExpression]: CallExpression;
    [ts.SyntaxKind.FunctionDeclaration]: FunctionDeclaration;
    [ts.SyntaxKind.Identifier]: DeclarationKind<ts.Identifier> & string;
    [ts.SyntaxKind.StringLiteral]: DeclarationKind<ts.StringLiteral> & string;
    [ts.SyntaxKind.TrueKeyword]: DeclarationKind<ts.TrueLiteral> & boolean;
    [ts.SyntaxKind.FalseKeyword]: DeclarationKind<ts.FalseLiteral> & boolean;
    [ts.SyntaxKind.ObjectLiteralExpression]: DeclarationKind<ts.ObjectLiteralExpression> & Record<string, any>;
    [ts.SyntaxKind.ArrayLiteralExpression]: DeclarationKind<ts.ArrayLiteralExpression> & any[];
};
export declare const defaultDeclarationDefinitionMap: DeclarationDefinitionMap<DefaultSyntaxKindToTSNodeDeclarationMap, DefaultDeclarationKindMap>;
